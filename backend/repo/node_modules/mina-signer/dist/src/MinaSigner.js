"use strict";
var JSOfOCaml_SDK = require("./client_sdk.bc.js");
var minaSDK = JSOfOCaml_SDK.minaSDK;
var defaultValidUntil = "4294967295";
var Client = /** @class */ (function () {
    function Client(options) {
        if (!(options === null || options === void 0 ? void 0 : options.network)) {
            throw "Invalid Specified Network";
        }
        var specifiedNetwork = options.network.toLowerCase();
        if (specifiedNetwork !== "mainnet" && specifiedNetwork !== "testnet") {
            throw "Invalid Specified Network";
        }
        this.network = specifiedNetwork;
    }
    /**
     * Generates a public/private key pair
     *
     * @returns A Mina key pair
     */
    Client.prototype.genKeys = function () {
        return minaSDK.genKeys();
    };
    /**
     * Verifies if a key pair is valid by checking if the public key can be derived from
     * the private key and additionally checking if we can use the private key to
     * sign a transaction. If the key pair is invalid, an exception is thrown.
     *
     * @param keypair A key pair
     * @returns True if the `keypair` is a verifiable key pair, otherwise throw an exception
     */
    Client.prototype.verifyKeypair = function (keypair) {
        return minaSDK.validKeypair(keypair);
    };
    /**
     * Derives the public key of the corresponding private key
     *
     * @param privateKey The private key used to get the corresponding public key
     * @returns A public key
     */
    Client.prototype.derivePublicKey = function (privateKey) {
        return minaSDK.publicKeyOfPrivateKey(privateKey);
    };
    /**
     * Signs an arbitrary message
     *
     * @param message An arbitrary string message to be signed
     * @param key The key pair used to sign the message
     * @returns A signed message
     */
    Client.prototype.signMessage = function (message, key) {
        return {
            signature: minaSDK.signString(this.network, key.privateKey, message),
            data: {
                publicKey: key.publicKey,
                message: message,
            },
        };
    };
    /**
     * Verifies that a signature matches a message.
     *
     * @param signedMessage A signed message
     * @returns True if the `signedMessage` contains a valid signature matching
     * the message and publicKey.
     */
    Client.prototype.verifyMessage = function (signedMessage) {
        return minaSDK.verifyStringSignature(this.network, signedMessage.signature, signedMessage.data.publicKey, signedMessage.data);
    };
    /**
     * Signs a payment transaction using a private key.
     *
     * This type of transaction allows a user to transfer funds from one account
     * to another over the network.
     *
     * @param payment An object describing the payment
     * @param privateKey The private key used to sign the transaction
     * @returns A signed payment transaction
     */
    Client.prototype.signPayment = function (payment, privateKey) {
        var _a, _b;
        var memo = (_a = payment.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(payment.fee);
        var nonce = String(payment.nonce);
        var amount = String(payment.amount);
        var validUntil = String((_b = payment.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return {
            signature: minaSDK.signPayment(this.network, privateKey, {
                common: {
                    fee: fee,
                    feePayer: payment.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                paymentPayload: {
                    source: payment.from,
                    receiver: payment.to,
                    amount: amount,
                },
            }).signature,
            data: {
                to: payment.to,
                from: payment.from,
                fee: fee,
                amount: amount,
                nonce: nonce,
                memo: memo,
                validUntil: validUntil,
            },
        };
    };
    /**
     * Verifies a signed payment.
     *
     * @param signedPayment A signed payment transaction
     * @returns True if the `signed(payment)` is a verifiable payment
     */
    Client.prototype.verifyPayment = function (signedPayment) {
        var _a, _b;
        var payload = signedPayment.data;
        var memo = (_a = payload.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(payload.fee);
        var amount = String(payload.amount);
        var nonce = String(payload.nonce);
        var validUntil = String((_b = payload.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return minaSDK.verifyPaymentSignature(this.network, {
            sender: signedPayment.data.from,
            signature: signedPayment.signature,
            payment: {
                common: {
                    fee: fee,
                    feePayer: payload.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                paymentPayload: {
                    source: payload.from,
                    receiver: payload.to,
                    amount: amount,
                },
            },
        });
    };
    /**
     * Signs a stake delegation transaction using a private key.
     *
     * This type of transaction allows a user to delegate their
     * funds from one account to another for use in staking. The
     * account that is delegated to is then considered as having these
     * funds when determining whether it can produce a block in a given slot.
     *
     * @param stakeDelegation An object describing the stake delegation
     * @param privateKey The private key used to sign the transaction
     * @returns A signed stake delegation
     */
    Client.prototype.signStakeDelegation = function (stakeDelegation, privateKey) {
        var _a, _b;
        var memo = (_a = stakeDelegation.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(stakeDelegation.fee);
        var nonce = String(stakeDelegation.nonce);
        var validUntil = String((_b = stakeDelegation.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return {
            signature: minaSDK.signStakeDelegation(this.network, privateKey, {
                common: {
                    fee: fee,
                    feePayer: stakeDelegation.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                delegationPayload: {
                    newDelegate: stakeDelegation.to,
                    delegator: stakeDelegation.from,
                },
            }).signature,
            data: {
                to: stakeDelegation.to,
                from: stakeDelegation.from,
                fee: fee,
                nonce: nonce,
                memo: memo,
                validUntil: validUntil,
            },
        };
    };
    /**
     * Verifies a signed stake delegation.
     *
     * @param signedStakeDelegation A signed stake delegation
     * @returns True if the `signed(stakeDelegation)` is a verifiable stake delegation
     */
    Client.prototype.verifyStakeDelegation = function (signedStakeDelegation) {
        var _a, _b;
        var payload = signedStakeDelegation.data;
        var memo = (_a = payload.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(payload.fee);
        var nonce = String(payload.nonce);
        var validUntil = String((_b = payload.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return minaSDK.verifyStakeDelegationSignature(this.network, {
            sender: signedStakeDelegation.data.from,
            signature: signedStakeDelegation.signature,
            stakeDelegation: {
                common: {
                    fee: fee,
                    feePayer: payload.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                delegationPayload: {
                    newDelegate: payload.to,
                    delegator: payload.from,
                },
            },
        });
    };
    /**
     * Compute the hash of a signed payment.
     *
     * @param signedPayment A signed payment transaction
     * @returns A transaction hash
     */
    Client.prototype.hashPayment = function (signedPayment) {
        var _a, _b;
        var payload = signedPayment.data;
        var memo = (_a = payload.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(payload.fee);
        var amount = String(payload.amount);
        var nonce = String(payload.nonce);
        var validUntil = String((_b = payload.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return minaSDK.hashPayment({
            sender: signedPayment.data.from,
            signature: signedPayment.signature,
            payment: {
                common: {
                    fee: fee,
                    feePayer: payload.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                paymentPayload: {
                    source: payload.from,
                    receiver: payload.to,
                    amount: amount,
                },
            },
        });
    };
    /**
     * Compute the hash of a signed stake delegation.
     *
     * @param signedStakeDelegation A signed stake delegation
     * @returns A transaction hash
     */
    Client.prototype.hashStakeDelegation = function (signedStakeDelegation) {
        var _a, _b;
        var payload = signedStakeDelegation.data;
        var memo = (_a = payload.memo) !== null && _a !== void 0 ? _a : "";
        var fee = String(payload.fee);
        var nonce = String(payload.nonce);
        var validUntil = String((_b = payload.validUntil) !== null && _b !== void 0 ? _b : defaultValidUntil);
        return minaSDK.hashStakeDelegation({
            sender: signedStakeDelegation.data.from,
            signature: signedStakeDelegation.signature,
            stakeDelegation: {
                common: {
                    fee: fee,
                    feePayer: payload.from,
                    nonce: nonce,
                    validUntil: validUntil,
                    memo: memo,
                },
                delegationPayload: {
                    newDelegate: payload.to,
                    delegator: payload.from,
                },
            },
        });
    };
    /**
     * Converts a Rosetta signed transaction to a JSON string that is
     * compatible with GraphQL. The JSON string is a representation of
     * a `Signed_command` which is what our GraphQL expects.
     *
     * @param signedRosettaTxn A signed Rosetta transaction
     * @returns A string that represents the JSON conversion of a signed Rosetta transaction`.
     */
    Client.prototype.signedRosettaTransactionToSignedCommand = function (signedRosettaTxn) {
        return minaSDK.signedRosettaTransactionToSignedCommand(signedRosettaTxn);
    };
    /**
     * Return the hex-encoded format of a valid public key. This will throw an exception if
     * the key is invalid or the conversion fails.
     *
     * @param publicKey A valid public key
     * @returns A string that represents the hex encoding of a public key.
     */
    Client.prototype.publicKeyToRaw = function (publicKey) {
        return minaSDK.rawPublicKeyOfPublicKey(publicKey);
    };
    return Client;
}());
module.exports = Client;
