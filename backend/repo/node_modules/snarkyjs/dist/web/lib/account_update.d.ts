import { Field, Bool, Pickles, AsFieldElements } from '../snarky.js';
import { Types } from '../snarky/types.js';
import { PrivateKey, PublicKey } from './signature.js';
import { UInt64, UInt32, Int64, Sign } from './int.js';
import { SmartContract } from './zkapp.js';
import * as Precondition from './precondition.js';
import { Proof } from './proof_system.js';
import { Context } from './global-context.js';
export { Permissions, AccountUpdate, ZkappPublicInput };
export { smartContractContext, SetOrKeep, Permission, Preconditions, Body, Authorization, FeePayerUnsigned, ZkappCommand, zkappCommandToJson, addMissingSignatures, addMissingProofs, signJsonTransaction, ZkappStateLength, Events, SequenceEvents, accountUpdateToPublicInput, TokenId, Token, CallForest, createChildAccountUpdate, makeChildAccountUpdate, AccountUpdatesLayout, };
declare const ZkappStateLength = 8;
declare let smartContractContext: Context.t<{
    this: SmartContract;
    methodCallDepth: number;
    isCallback: boolean;
    selfUpdate: AccountUpdate;
}>;
declare type AccountUpdateBody = Types.AccountUpdate['body'];
declare type Update = AccountUpdateBody['update'];
/**
 * Preconditions for the network and accounts
 */
declare type Preconditions = AccountUpdateBody['preconditions'];
/**
 * Either set a value or keep it the same.
 */
declare type SetOrKeep<T> = {
    isSome: Bool;
    value: T;
};
/**
 * One specific permission value.
 *
 * A [[ Permission ]] tells one specific permission for our zkapp how it should behave
 * when presented with requested modifications.
 *
 * Use static factory methods on this class to use a specific behavior. See
 * documentation on those methods to learn more.
 */
declare type Permission = Types.AuthRequired;
declare let Permission: {
    /**
     * Modification is impossible.
     */
    impossible: () => Permission;
    /**
     * Modification is always permitted
     */
    none: () => Permission;
    /**
     * Modification is permitted by zkapp proofs only
     */
    proof: () => Permission;
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => Permission;
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => Permission;
};
declare type Permissions_ = Update['permissions']['value'];
/**
 * Permissions specify how specific aspects of the zkapp account are allowed to
 * be modified. All fields are denominated by a [[ Permission ]].
 */
interface Permissions extends Permissions_ {
    /**
     * The [[ Permission ]] corresponding to the 8 state fields associated with an
     * account.
     */
    editState: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to send transactions from this
     * account.
     */
    send: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to receive transactions to this
     * account.
     */
    receive: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to set the delegate field of
     * the account.
     */
    setDelegate: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to set the permissions field of
     * the account.
     */
    setPermissions: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to set the verification key
     * associated with the circuit tied to this account. Effectively
     * "upgradability" of the smart contract.
     */
    setVerificationKey: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to set the zkapp uri typically
     * pointing to the source code of the smart contract. Usually this should be
     * changed whenever the [[ Permissions.setVerificationKey ]] is changed.
     * Effectively "upgradability" of the smart contract.
     */
    setZkappUri: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to change the sequence state
     * associated with the account.
     *
     * TODO: Define sequence state here as well.
     */
    editSequenceState: Permission;
    /**
     * The [[ Permission ]] corresponding to the ability to set the token symbol for
     * this account.
     */
    setTokenSymbol: Permission;
    incrementNonce: Permission;
    setVotingFor: Permission;
}
declare let Permissions: {
    /**
     * Default permissions are:
     *   [[ Permissions.editState ]]=[[ Permission.proof ]]
     *   [[ Permissions.send ]]=[[ Permission.signature ]]
     *   [[ Permissions.receive ]]=[[ Permission.none ]]
     *   [[ Permissions.setDelegate ]]=[[ Permission.signature ]]
     *   [[ Permissions.setPermissions ]]=[[ Permission.signature ]]
     *   [[ Permissions.setVerificationKey ]]=[[ Permission.signature ]]
     *   [[ Permissions.setZkappUri ]]=[[ Permission.signature ]]
     *   [[ Permissions.editSequenceState ]]=[[ Permission.proof ]]
     *   [[ Permissions.setTokenSymbol ]]=[[ Permission.signature ]]
     */
    default: () => Permissions;
    initial: () => Permissions;
    /**
     * Modification is impossible.
     */
    impossible: () => Permission;
    /**
     * Modification is always permitted
     */
    none: () => Permission;
    /**
     * Modification is permitted by zkapp proofs only
     */
    proof: () => Permission;
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => Permission;
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => Permission;
};
declare type Event = Field[];
declare type Events = {
    hash: Field;
    data: Event[];
};
declare const Events: {
    empty(): Events;
    pushEvent(events: Events, event: Event): Events;
    hash(events: Event[]): Field;
};
declare const SequenceEvents: {
    empty(): Events;
    pushEvent(sequenceEvents: Events, event: Event): Events;
    hash(events: Event[]): Field;
    emptySequenceState(): Field;
    updateSequenceState(state: Field, sequenceEventsHash: Field): Field;
};
/**
 * The body of describing how some [[ AccountUpdate ]] should change.
 *
 * TODO: We need to rename this still.
 */
interface Body extends AccountUpdateBody {
    /**
     * The address for this body.
     */
    publicKey: PublicKey;
    /**
     * Specify [[ Update ]]s to tweakable pieces of the account record backing
     * this address in the ledger.
     */
    update: Update;
    /**
     * The TokenId for this account.
     */
    tokenId: Field;
    /**
     * By what [[ Int64 ]] should the balance of this account change. All
     * balanceChanges must balance by the end of smart contract execution.
     */
    balanceChange: {
        magnitude: UInt64;
        sgn: Sign;
    };
    /**
     * Recent events that have been emitted from this account.
     *
     * TODO: Add a reference to general explanation of events.
     */
    events: Events;
    sequenceEvents: Events;
    caller: Field;
    callData: Field;
    callDepth: number;
    preconditions: Preconditions;
    useFullCommitment: Bool;
    incrementNonce: Bool;
}
declare const Body: {
    noUpdate(): Update;
    /**
     * A body that Don't change part of the underlying account record.
     */
    keepAll(publicKey: PublicKey): Body;
    dummy(): Body;
};
declare type FeePayer = Types.ZkappCommand['feePayer'];
declare type FeePayerUnsigned = FeePayer & {
    lazyAuthorization?: LazySignature | undefined;
};
/**
 * Either check a value or ignore it.
 *
 * Used within [[ AccountPredicate ]]s and [[ ProtocolStatePredicate ]]s.
 */
declare type OrIgnore<T> = {
    isSome: Bool;
    value: T;
};
/**
 * An interval representing all the values between `lower` and `upper` inclusive
 * of both the `lower` and `upper` values.
 *
 * @typeParam A something with an ordering where one can quantify a lower and
 *            upper bound.
 */
declare type ClosedInterval<T> = {
    lower: T;
    upper: T;
};
declare const Preconditions: {
    ignoreAll(): Preconditions;
};
declare type Control = Types.AccountUpdate['authorization'];
declare type LazySignature = {
    kind: 'lazy-signature';
    privateKey?: PrivateKey;
};
declare type LazyProof = {
    kind: 'lazy-proof';
    methodName: string;
    args: any[];
    previousProofs: {
        publicInput: Field[];
        proof: Pickles.Proof;
    }[];
    ZkappClass: typeof SmartContract;
    memoized: Field[][];
    blindingValue: Field;
};
declare const TokenId: {
    default: Field;
    toBase58(field: Field): string;
    fromBase58(base58: string): Field;
    toFields: (x: Field) => Field[];
    ofFields: (x: Field[]) => Field;
    sizeInFields(): number;
    check: (x: Field) => void;
    toInput: (x: Field) => {
        fields?: Field[] | undefined;
        packed?: [Field, number][] | undefined;
    };
    toJSON: (x: Field) => import("../snarky.js").JSONValue;
};
declare class Token {
    readonly id: Field;
    readonly parentTokenId: Field;
    readonly tokenOwner: PublicKey;
    static Id: {
        default: Field;
        toBase58(field: Field): string;
        fromBase58(base58: string): Field;
        toFields: (x: Field) => Field[];
        ofFields: (x: Field[]) => Field;
        sizeInFields(): number;
        check: (x: Field) => void;
        toInput: (x: Field) => {
            fields?: Field[] | undefined;
            packed?: [Field, number][] | undefined;
        };
        toJSON: (x: Field) => import("../snarky.js").JSONValue;
    };
    static getId(tokenOwner: PublicKey, parentTokenId?: Field): Field;
    constructor({ tokenOwner, parentTokenId, }: {
        tokenOwner: PublicKey;
        parentTokenId?: Field;
    });
}
declare class AccountUpdate implements Types.AccountUpdate {
    body: Body;
    authorization: Control;
    lazyAuthorization: LazySignature | LazyProof | undefined;
    account: Precondition.Account;
    network: Precondition.Network;
    children: {
        calls?: Field;
        accountUpdates: AccountUpdate[];
    };
    parent: AccountUpdate | undefined;
    private isSelf;
    constructor(body: Body, authorization?: Control);
    static clone(accountUpdate: AccountUpdate): any;
    token(): {
        id: Field;
        parentTokenId: Field;
        tokenOwner: Types.PublicKey;
        mint({ address, amount, }: {
            address: PublicKey;
            amount: number | bigint | UInt64;
        }): AccountUpdate;
        burn({ address, amount, }: {
            address: PublicKey;
            amount: number | bigint | UInt64;
        }): void;
        send({ from, to, amount, }: {
            from: PublicKey;
            to: PublicKey;
            amount: number | bigint | UInt64;
        }): AccountUpdate;
    };
    get tokenId(): Field;
    get tokenSymbol(): {
        set(tokenSymbol: string): void;
    };
    send({ to, amount, }: {
        to: PublicKey | AccountUpdate;
        amount: number | bigint | UInt64;
    }): void;
    get balance(): {
        addInPlace(x: Int64 | UInt32 | UInt64 | string | number | bigint): void;
        subInPlace(x: Int64 | UInt32 | UInt64 | string | number | bigint): void;
    };
    get update(): Update;
    static setValue<T>(maybeValue: SetOrKeep<T>, value: T): void;
    /** Constrain a property to lie between lower and upper bounds.
     *
     * @param property The property to constrain
     * @param lower The lower bound
     * @param upper The upper bound
     *
     * Example: To constrain the account balance of a SmartContract to lie between 0 and 20 MINA, you can use
     *
     * ```ts
     * @method onlyRunsWhenBalanceIsLow() {
     *   let lower = UInt64.zero;
     *   let upper = UInt64.fromNumber(20e9);
     *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
     *   // ...
     * }
     * ```
     */
    static assertBetween<T>(property: OrIgnore<ClosedInterval<T>>, lower: T, upper: T): void;
    /** Fix a property to a certain value.
     *
     * @param property The property to constrain
     * @param value The value it is fixed to
     *
     * Example: To fix the account nonce of a SmartContract to 0, you can use
     *
     * ```ts
     * @method onlyRunsWhenNonceIsZero() {
     *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
     *   // ...
     * }
     * ```
     */
    static assertEquals<T>(property: OrIgnore<ClosedInterval<T> | T>, value: T): void;
    get publicKey(): PublicKey;
    sign(privateKey?: PrivateKey): void;
    static signFeePayerInPlace(feePayer: FeePayerUnsigned, privateKey?: PrivateKey): void;
    static getNonce(accountUpdate: AccountUpdate | FeePayerUnsigned): any;
    private static getNonceUnchecked;
    toFields(): Field[];
    toJSON(): Types.Json.AccountUpdate;
    hash(): Field;
    toPublicInput(): ZkappPublicInput;
    static defaultAccountUpdate(address: PublicKey, tokenId?: Field): AccountUpdate;
    static dummy(): AccountUpdate;
    isDummy(): Bool;
    static defaultFeePayer(address: PublicKey, key: PrivateKey, nonce: UInt32): FeePayerUnsigned;
    static dummyFeePayer(): FeePayerUnsigned;
    static create(publicKey: PublicKey, tokenId?: Field): AccountUpdate;
    static createSigned(signer: PrivateKey): AccountUpdate;
    /**
     * Use this method to pay the account creation fee for another account.
     * Beware that you _don't_ need to pass in the new account!
     * Instead, the protocol will automatically identify accounts in your transaction that need funding.
     *
     * If you provide an optional `initialBalance`, this will be subtracted from the fee-paying account as well,
     * but you have to separately ensure that it's added to the new account's balance.
     *
     * @param feePayerKey the private key of the account that pays the fee
     * @param initialBalance the initial balance of the new account (default: 0)
     */
    static fundNewAccount(feePayerKey: PrivateKey, { initialBalance }?: {
        initialBalance?: string | number | Types.UInt64 | undefined;
    }): void;
    static witness<T>(type: AsFieldElements<T>, compute: () => {
        accountUpdate: AccountUpdate;
        result: T;
    }, { skipCheck }?: {
        skipCheck?: boolean | undefined;
    }): {
        accountUpdate: AccountUpdate;
        result: T;
    };
    /**
     * Like AccountUpdate.witness, but lets you specify a layout for the accountUpdate's children,
     * which also get witnessed
     */
    static witnessTree<T>(resultType: AsFieldElements<T>, childLayout: AccountUpdatesLayout, compute: () => {
        accountUpdate: AccountUpdate;
        result: T;
    }, options?: {
        skipCheck: boolean;
    }): {
        accountUpdate: AccountUpdate;
        result: T;
    };
}
/**
 * Describes list of accountUpdates (call forest) to be witnessed.
 *
 * An accountUpdates list is represented by either
 * - an array, whose entries are accountUpdates, each represented by their list of children
 * - a positive integer, which gives the number of top-level accountUpdates, which aren't allowed to have further children
 * - `undefined`, which means just the `calls` (call forest hash) is witnessed, allowing arbitrary accountUpdates but no access to them in the circuit
 *
 * Examples:
 * ```ts
 * []              // an empty accountUpdates list
 * 0               // same as []
 * [0]             // a list of one accountUpdate, which doesn't have children
 * 1               // same as [0]
 * 2               // same as [0, 0]
 * undefined       // an arbitrary list of accountUpdates
 * [undefined, 1]  // a list of 2 accountUpdates, of which one has arbitrary children and the other has exactly 1 child
 * ```
 */
declare type AccountUpdatesLayout = number | undefined | AccountUpdatesLayout[];
declare const CallForest: {
    toFlatList(forest: AccountUpdate[], depth?: number): AccountUpdate[];
    emptyHash(): Field;
    hashChildren({ children }: AccountUpdate): Field;
    forEach(updates: AccountUpdate[], callback: (update: AccountUpdate) => void): void;
    forEachPredecessor(updates: AccountUpdate[], update: AccountUpdate, callback: (update: AccountUpdate) => void): void;
};
declare function createChildAccountUpdate(parent: AccountUpdate, childAddress: PublicKey, tokenId?: Field): AccountUpdate;
declare function makeChildAccountUpdate(parent: AccountUpdate, child: AccountUpdate): void;
declare type ZkappCommand = {
    feePayer: FeePayerUnsigned;
    accountUpdates: AccountUpdate[];
    memo: string;
};
declare type ZkappCommandSigned = {
    feePayer: FeePayer;
    accountUpdates: (AccountUpdate & {
        lazyAuthorization?: LazyProof;
    })[];
    memo: string;
};
declare type ZkappCommandProved = {
    feePayer: FeePayerUnsigned;
    accountUpdates: (AccountUpdate & {
        lazyAuthorization?: LazySignature;
    })[];
    memo: string;
};
declare function zkappCommandToJson({ feePayer, accountUpdates, memo }: ZkappCommand): Types.Json.ZkappCommand;
declare const Authorization: {
    hasLazyProof(accountUpdate: AccountUpdate): boolean;
    hasAny(accountUpdate: AccountUpdate): boolean;
    setSignature(accountUpdate: AccountUpdate, signature: string): void;
    setProof(accountUpdate: AccountUpdate, proof: string): void;
    setLazySignature(accountUpdate: AccountUpdate, signature?: Omit<LazySignature, 'kind'>): void;
    setLazyProof(accountUpdate: AccountUpdate, proof: Omit<LazyProof, 'kind'>): void;
};
declare function addMissingSignatures(zkappCommand: ZkappCommand, additionalKeys?: PrivateKey[]): ZkappCommandSigned;
/**
 * The public input for zkApps consists of certain hashes of the proving AccountUpdate (and its child accountUpdates) which is constructed during method execution.

  For SmartContract proving, a method is run twice: First outside the proof, to obtain the public input, and once in the prover,
  which takes the public input as input. The current transaction is hashed again inside the prover, which asserts that the result equals the input public input,
  as part of the snark circuit. The block producer will also hash the transaction they receive and pass it as a public input to the verifier.
  Thus, the transaction is fully constrained by the proof - the proof couldn't be used to attest to a different transaction.
 */
declare type ZkappPublicInput = {
    accountUpdate: Field;
    calls: Field;
};
declare let ZkappPublicInput: import("./circuit_value.js").AsFieldsExtended<ZkappPublicInput>;
declare function accountUpdateToPublicInput(self: AccountUpdate): ZkappPublicInput;
declare function addMissingProofs(zkappCommand: ZkappCommand): Promise<{
    zkappCommand: ZkappCommandProved;
    proofs: (Proof<ZkappPublicInput> | undefined)[];
}>;
/**
 * Sign all accountUpdates of a transaction which belong to the account determined by [[ `privateKey` ]].
 * @returns the modified transaction JSON
 */
declare function signJsonTransaction(transactionJson: string, privateKey: PrivateKey | string): string;
