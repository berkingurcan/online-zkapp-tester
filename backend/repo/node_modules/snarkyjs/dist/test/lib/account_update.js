import { circuitArray, circuitValue, cloneCircuitValue, memoizationContext, memoizeWitness, } from './circuit_value.js';
import { Field, Bool, Ledger, Circuit, Pickles, } from '../snarky.js';
import { Types } from '../snarky/types.js';
import { PrivateKey, PublicKey } from './signature.js';
import { UInt64, UInt32, Int64 } from './int.js';
import * as Mina from './mina.js';
import * as Precondition from './precondition.js';
import { inCheckedComputation, snarkContext } from './proof_system.js';
import { emptyHashWithPrefix, hashWithPrefix, packToFields, prefixes, TokenSymbol, } from './hash.js';
import * as Encoding from './encoding.js';
import { Context } from './global-context.js';
// external API
export { Permissions, AccountUpdate, ZkappPublicInput };
// internal API
export { smartContractContext, Permission, Preconditions, Body, Authorization, zkappCommandToJson, addMissingSignatures, addMissingProofs, signJsonTransaction, ZkappStateLength, Events, SequenceEvents, accountUpdateToPublicInput, TokenId, Token, CallForest, createChildAccountUpdate, makeChildAccountUpdate, };
const ZkappStateLength = 8;
let smartContractContext = Context.create();
function keep(dummy) {
    return { isSome: Bool(false), value: dummy };
}
const True = () => Bool(true);
const False = () => Bool(false);
let Permission = {
    /**
     * Modification is impossible.
     */
    impossible: () => ({
        constant: True(),
        signatureNecessary: True(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is always permitted
     */
    none: () => ({
        constant: True(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs only
     */
    proof: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: False(),
    }),
    /**
     * Modification is permitted by signatures only, using the private key of the zkapp account
     */
    signature: () => ({
        constant: False(),
        signatureNecessary: True(),
        signatureSufficient: True(),
    }),
    /**
     * Modification is permitted by zkapp proofs or signatures
     */
    proofOrSignature: () => ({
        constant: False(),
        signatureNecessary: False(),
        signatureSufficient: True(),
    }),
};
let Permissions = {
    ...Permission,
    /**
     * Default permissions are:
     *   [[ Permissions.editState ]]=[[ Permission.proof ]]
     *   [[ Permissions.send ]]=[[ Permission.signature ]]
     *   [[ Permissions.receive ]]=[[ Permission.none ]]
     *   [[ Permissions.setDelegate ]]=[[ Permission.signature ]]
     *   [[ Permissions.setPermissions ]]=[[ Permission.signature ]]
     *   [[ Permissions.setVerificationKey ]]=[[ Permission.signature ]]
     *   [[ Permissions.setZkappUri ]]=[[ Permission.signature ]]
     *   [[ Permissions.editSequenceState ]]=[[ Permission.proof ]]
     *   [[ Permissions.setTokenSymbol ]]=[[ Permission.signature ]]
     */
    default: () => ({
        editState: Permission.proof(),
        send: Permission.signature(),
        receive: Permission.none(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.proof(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permissions.signature(),
        setVotingFor: Permission.signature(),
    }),
    initial: () => ({
        editState: Permission.signature(),
        send: Permission.signature(),
        receive: Permission.none(),
        setDelegate: Permission.signature(),
        setPermissions: Permission.signature(),
        setVerificationKey: Permission.signature(),
        setZkappUri: Permission.signature(),
        editSequenceState: Permission.signature(),
        setTokenSymbol: Permission.signature(),
        incrementNonce: Permissions.signature(),
        setVotingFor: Permission.signature(),
    }),
};
const Events = {
    empty() {
        let hash = emptyHashWithPrefix('MinaZkappEventsEmpty');
        return { hash, data: [] };
    },
    pushEvent(events, event) {
        let eventHash = hashWithPrefix(prefixes.event, event);
        let hash = hashWithPrefix(prefixes.events, [events.hash, eventHash]);
        return { hash, data: [event, ...events.data] };
    },
    hash(events) {
        return [...events].reverse().reduce(Events.pushEvent, Events.empty()).hash;
    },
};
const SequenceEvents = {
    // same as events but w/ different hash prefixes
    empty() {
        let hash = emptyHashWithPrefix('MinaZkappSequenceEmpty');
        return { hash, data: [] };
    },
    pushEvent(sequenceEvents, event) {
        let eventHash = hashWithPrefix(prefixes.event, event);
        let hash = hashWithPrefix(prefixes.sequenceEvents, [
            sequenceEvents.hash,
            eventHash,
        ]);
        return { hash, data: [event, ...sequenceEvents.data] };
    },
    hash(events) {
        return [...events]
            .reverse()
            .reduce(SequenceEvents.pushEvent, SequenceEvents.empty()).hash;
    },
    // different than events
    emptySequenceState() {
        return emptyHashWithPrefix('MinaZkappSequenceStateEmptyElt');
    },
    updateSequenceState(state, sequenceEventsHash) {
        return hashWithPrefix(prefixes.sequenceEvents, [state, sequenceEventsHash]);
    },
};
const Body = {
    noUpdate() {
        return {
            appState: Array(ZkappStateLength)
                .fill(0)
                .map(() => keep(Field.zero)),
            delegate: keep(PublicKey.empty()),
            // TODO
            verificationKey: keep({ data: '', hash: Field.zero }),
            permissions: keep(Permissions.initial()),
            // TODO don't hard code
            zkappUri: keep({
                data: '',
                hash: Field('22930868938364086394602058221028773520482901241511717002947639863679740444066'),
            }),
            // TODO
            tokenSymbol: keep(TokenSymbol.empty),
            timing: keep({
                cliffAmount: UInt64.zero,
                cliffTime: UInt32.zero,
                initialMinimumBalance: UInt64.zero,
                vestingIncrement: UInt64.zero,
                vestingPeriod: UInt32.zero,
            }),
            votingFor: keep(Field.zero),
        };
    },
    /**
     * A body that Don't change part of the underlying account record.
     */
    keepAll(publicKey) {
        return {
            publicKey,
            update: Body.noUpdate(),
            tokenId: TokenId.default,
            balanceChange: Int64.zero,
            events: Events.empty(),
            sequenceEvents: SequenceEvents.empty(),
            caller: TokenId.default,
            callData: Field.zero,
            callDepth: 0,
            preconditions: Preconditions.ignoreAll(),
            // the default assumption is that snarkyjs transactions don't include the fee payer
            // so useFullCommitment has to be false for signatures to be correct
            useFullCommitment: Bool(false),
            // this should be set to true if accountUpdates are signed
            incrementNonce: Bool(false),
        };
    },
    dummy() {
        return Body.keepAll(PublicKey.empty());
    },
};
const FeePayerBody = {
    keepAll(publicKey, nonce) {
        return {
            publicKey,
            nonce,
            fee: UInt64.zero,
            validUntil: undefined,
        };
    },
};
let NetworkPrecondition = {
    ignoreAll() {
        let stakingEpochData = {
            ledger: { hash: ignore(Field.zero), totalCurrency: ignore(uint64()) },
            seed: ignore(Field.zero),
            startCheckpoint: ignore(Field.zero),
            lockCheckpoint: ignore(Field.zero),
            epochLength: ignore(uint32()),
        };
        let nextEpochData = cloneCircuitValue(stakingEpochData);
        return {
            snarkedLedgerHash: ignore(Field.zero),
            timestamp: ignore(uint64()),
            blockchainLength: ignore(uint32()),
            minWindowDensity: ignore(uint32()),
            totalCurrency: ignore(uint64()),
            globalSlotSinceHardFork: ignore(uint32()),
            globalSlotSinceGenesis: ignore(uint32()),
            stakingEpochData,
            nextEpochData,
        };
    },
};
/**
 * Ignores a `dummy`
 *
 * @param dummy The value to ignore
 * @returns Always an ignored value regardless of the input.
 */
function ignore(dummy) {
    return { isSome: Bool(false), value: dummy };
}
/**
 * Ranges between all uint32 values
 */
const uint32 = () => ({ lower: UInt32.fromNumber(0), upper: UInt32.MAXINT() });
/**
 * Ranges between all uint64 values
 */
const uint64 = () => ({ lower: UInt64.fromNumber(0), upper: UInt64.MAXINT() });
const AccountPrecondition = {
    ignoreAll() {
        let appState = [];
        for (let i = 0; i < ZkappStateLength; ++i) {
            appState.push(ignore(Field.zero));
        }
        return {
            balance: ignore(uint64()),
            nonce: ignore(uint32()),
            receiptChainHash: ignore(Field.zero),
            delegate: ignore(PublicKey.empty()),
            state: appState,
            sequenceState: ignore(SequenceEvents.emptySequenceState()),
            provedState: ignore(Bool(false)),
            isNew: ignore(Bool(false)),
        };
    },
    nonce(nonce) {
        let p = AccountPrecondition.ignoreAll();
        AccountUpdate.assertEquals(p.nonce, nonce);
        return p;
    },
};
const Preconditions = {
    ignoreAll() {
        return {
            account: AccountPrecondition.ignoreAll(),
            network: NetworkPrecondition.ignoreAll(),
        };
    },
};
const TokenId = {
    ...Types.TokenId,
    ...Encoding.TokenId,
    get default() {
        return Field.one;
    },
};
class Token {
    constructor({ tokenOwner, parentTokenId = TokenId.default, }) {
        this.parentTokenId = parentTokenId;
        this.tokenOwner = tokenOwner;
        try {
            this.id = Token.getId(tokenOwner, parentTokenId);
        }
        catch (e) {
            throw new Error(`Could not create a custom token id:\nError: ${e.message}`);
        }
    }
    static getId(tokenOwner, parentTokenId = TokenId.default) {
        if (tokenOwner.isConstant() && parentTokenId.isConstant()) {
            return Ledger.customTokenId(tokenOwner, parentTokenId);
        }
        else {
            return Ledger.customTokenIdChecked(tokenOwner, parentTokenId);
        }
    }
}
Token.Id = TokenId;
class AccountUpdate {
    constructor(body, authorization = {}, isSelf = false) {
        this.lazyAuthorization = undefined;
        this.children = {
            accountUpdates: [],
        };
        this.parent = undefined;
        this.body = body;
        this.authorization = authorization;
        let { account, network } = Precondition.preconditions(this, isSelf);
        this.account = account;
        this.network = network;
        this.isSelf = isSelf;
    }
    static clone(accountUpdate) {
        let body = cloneCircuitValue(accountUpdate.body);
        let authorization = cloneCircuitValue(accountUpdate.authorization);
        let clonedAccountUpdate = new AccountUpdate(body, authorization, accountUpdate.isSelf);
        clonedAccountUpdate.lazyAuthorization = cloneCircuitValue(accountUpdate.lazyAuthorization);
        clonedAccountUpdate.children = accountUpdate.children;
        clonedAccountUpdate.parent = accountUpdate.parent;
        return clonedAccountUpdate;
    }
    token() {
        let thisAccountUpdate = this;
        let customToken = new Token({
            tokenOwner: thisAccountUpdate.body.publicKey,
            parentTokenId: thisAccountUpdate.body.tokenId,
        });
        return {
            id: customToken.id,
            parentTokenId: customToken.parentTokenId,
            tokenOwner: customToken.tokenOwner,
            mint({ address, amount, }) {
                let receiverAccountUpdate = createChildAccountUpdate(thisAccountUpdate, address, this.id);
                // Add the amount to mint to the receiver's account
                receiverAccountUpdate.body.balanceChange = Int64.fromObject(receiverAccountUpdate.body.balanceChange).add(amount);
                return receiverAccountUpdate;
            },
            burn({ address, amount, }) {
                let senderAccountUpdate = createChildAccountUpdate(thisAccountUpdate, address, this.id);
                senderAccountUpdate.body.useFullCommitment = Bool(true);
                // Sub the amount to burn from the sender's account
                senderAccountUpdate.body.balanceChange = Int64.fromObject(senderAccountUpdate.body.balanceChange).sub(amount);
                // Require signature from the sender account being deducted
                Authorization.setLazySignature(senderAccountUpdate);
            },
            send({ from, to, amount, }) {
                // Create a new accountUpdate for the sender to send the amount to the receiver
                let senderAccountUpdate = createChildAccountUpdate(thisAccountUpdate, from, this.id);
                senderAccountUpdate.body.useFullCommitment = Bool(true);
                let i0 = senderAccountUpdate.body.balanceChange;
                senderAccountUpdate.body.balanceChange = new Int64(i0.magnitude, i0.sgn).sub(amount);
                // Require signature from the sender accountUpdate
                Authorization.setLazySignature(senderAccountUpdate);
                let receiverAccountUpdate = createChildAccountUpdate(thisAccountUpdate, to, this.id);
                // Add the amount to send to the receiver's account
                let i1 = receiverAccountUpdate.body.balanceChange;
                receiverAccountUpdate.body.balanceChange = new Int64(i1.magnitude, i1.sgn).add(amount);
                return receiverAccountUpdate;
            },
        };
    }
    get tokenId() {
        return this.body.tokenId;
    }
    get tokenSymbol() {
        let accountUpdate = this;
        return {
            set(tokenSymbol) {
                AccountUpdate.setValue(accountUpdate.update.tokenSymbol, TokenSymbol.from(tokenSymbol));
            },
        };
    }
    send({ to, amount, }) {
        let accountUpdate = this;
        let receiverAccountUpdate;
        if (to instanceof AccountUpdate) {
            receiverAccountUpdate = to;
            receiverAccountUpdate.body.tokenId.assertEquals(accountUpdate.body.tokenId);
        }
        else {
            receiverAccountUpdate = AccountUpdate.defaultAccountUpdate(to, accountUpdate.body.tokenId);
        }
        makeChildAccountUpdate(accountUpdate, receiverAccountUpdate);
        // Sub the amount from the sender's account
        accountUpdate.body.balanceChange = Int64.fromObject(accountUpdate.body.balanceChange).sub(amount);
        // Add the amount to send to the receiver's account
        receiverAccountUpdate.body.balanceChange = Int64.fromObject(receiverAccountUpdate.body.balanceChange).add(amount);
    }
    get balance() {
        let accountUpdate = this;
        return {
            addInPlace(x) {
                let { magnitude, sgn } = accountUpdate.body.balanceChange;
                accountUpdate.body.balanceChange = new Int64(magnitude, sgn).add(x);
            },
            subInPlace(x) {
                let { magnitude, sgn } = accountUpdate.body.balanceChange;
                accountUpdate.body.balanceChange = new Int64(magnitude, sgn).sub(x);
            },
        };
    }
    get update() {
        return this.body.update;
    }
    static setValue(maybeValue, value) {
        maybeValue.isSome = Bool(true);
        maybeValue.value = value;
    }
    /** Constrain a property to lie between lower and upper bounds.
     *
     * @param property The property to constrain
     * @param lower The lower bound
     * @param upper The upper bound
     *
     * Example: To constrain the account balance of a SmartContract to lie between 0 and 20 MINA, you can use
     *
     * ```ts
     * @method onlyRunsWhenBalanceIsLow() {
     *   let lower = UInt64.zero;
     *   let upper = UInt64.fromNumber(20e9);
     *   AccountUpdate.assertBetween(this.self.body.preconditions.account.balance, lower, upper);
     *   // ...
     * }
     * ```
     */
    static assertBetween(property, lower, upper) {
        property.isSome = Bool(true);
        property.value.lower = lower;
        property.value.upper = upper;
    }
    // TODO: assertGreaterThan, assertLowerThan?
    /** Fix a property to a certain value.
     *
     * @param property The property to constrain
     * @param value The value it is fixed to
     *
     * Example: To fix the account nonce of a SmartContract to 0, you can use
     *
     * ```ts
     * @method onlyRunsWhenNonceIsZero() {
     *   AccountUpdate.assertEquals(this.self.body.preconditions.account.nonce, UInt32.zero);
     *   // ...
     * }
     * ```
     */
    static assertEquals(property, value) {
        property.isSome = Bool(true);
        if ('lower' in property.value && 'upper' in property.value) {
            property.value.lower = value;
            property.value.upper = value;
        }
        else {
            property.value = value;
        }
    }
    get publicKey() {
        return this.body.publicKey;
    }
    sign(privateKey) {
        let nonce = AccountUpdate.getNonce(this);
        this.account.nonce.assertEquals(nonce);
        this.body.incrementNonce = Bool(true);
        Authorization.setLazySignature(this, { privateKey });
    }
    static signFeePayerInPlace(feePayer, privateKey) {
        feePayer.body.nonce = this.getNonce(feePayer);
        feePayer.authorization = Ledger.dummySignature();
        feePayer.lazyAuthorization = { kind: 'lazy-signature', privateKey };
    }
    static getNonce(accountUpdate) {
        return memoizeWitness(UInt32, () => AccountUpdate.getNonceUnchecked(accountUpdate));
    }
    static getNonceUnchecked(update) {
        let publicKey = update.body.publicKey;
        let tokenId = update instanceof AccountUpdate ? update.body.tokenId : TokenId.default;
        let nonce = Number(Precondition.getAccountPreconditions(update.body).nonce.toString());
        // if the fee payer is the same account update as this one, we have to start the nonce predicate at one higher,
        // bc the fee payer already increases its nonce
        let isFeePayer = Mina.currentTransaction()?.sender?.equals(publicKey);
        if (isFeePayer?.toBoolean())
            nonce++;
        // now, we check how often this accountUpdate already updated its nonce in this tx, and increase nonce from `getAccount` by that amount
        CallForest.forEachPredecessor(Mina.currentTransaction.get().accountUpdates, update, (otherUpdate) => {
            let shouldIncreaseNonce = otherUpdate.publicKey
                .equals(publicKey)
                .and(otherUpdate.tokenId.equals(tokenId))
                .and(otherUpdate.body.incrementNonce);
            if (shouldIncreaseNonce.toBoolean())
                nonce++;
        });
        return UInt32.from(nonce);
    }
    toFields() {
        return Types.AccountUpdate.toFields(this);
    }
    toJSON() {
        return Types.AccountUpdate.toJSON(this);
    }
    hash() {
        // these two ways of hashing are (and have to be) consistent / produce the same hash
        // TODO: there's no reason anymore to use two different hashing methods here!
        // -- the "inCheckedComputation" branch works in all circumstances now
        // we just leave this here for a couple more weeks, because it checks consistency between
        // JS & OCaml hashing on *every single accountUpdate proof* we create. It will give us 100%
        // confidence that the two implementations are equivalent, and catch regressions quickly
        if (inCheckedComputation()) {
            let input = Types.AccountUpdate.toInput(this);
            return hashWithPrefix(prefixes.body, packToFields(input));
        }
        else {
            let json = Types.AccountUpdate.toJSON(this);
            return Ledger.hashAccountUpdateFromJson(JSON.stringify(json));
        }
    }
    // TODO: this was only exposed to be used in a unit test
    // consider removing when we have inline unit tests
    toPublicInput() {
        let accountUpdate = this.hash();
        let calls = CallForest.hashChildren(this);
        return { accountUpdate, calls };
    }
    static defaultAccountUpdate(address, tokenId) {
        const body = Body.keepAll(address);
        if (tokenId) {
            body.tokenId = tokenId;
            body.caller = tokenId;
        }
        return new AccountUpdate(body);
    }
    static dummy() {
        return this.defaultAccountUpdate(PublicKey.empty());
    }
    isDummy() {
        return this.body.publicKey.isEmpty();
    }
    static defaultFeePayer(address, key, nonce) {
        let body = FeePayerBody.keepAll(address, nonce);
        return {
            body,
            authorization: Ledger.dummySignature(),
            lazyAuthorization: { kind: 'lazy-signature', privateKey: key },
        };
    }
    static dummyFeePayer() {
        let body = FeePayerBody.keepAll(PublicKey.empty(), UInt32.zero);
        return { body, authorization: Ledger.dummySignature() };
    }
    static create(publicKey, tokenId) {
        let accountUpdate = AccountUpdate.defaultAccountUpdate(publicKey, tokenId);
        if (smartContractContext.has()) {
            makeChildAccountUpdate(smartContractContext.get().this.self, accountUpdate);
        }
        else {
            Mina.currentTransaction()?.accountUpdates.push(accountUpdate);
        }
        return accountUpdate;
    }
    static createSigned(signer) {
        let publicKey = signer.toPublicKey();
        if (!Mina.currentTransaction.has()) {
            throw new Error('AccountUpdate.createSigned: Cannot run outside of a transaction');
        }
        let accountUpdate = AccountUpdate.defaultAccountUpdate(publicKey);
        // it's fine to compute the nonce outside the circuit, because we're constraining it with a precondition
        let nonce = Circuit.witness(UInt32, () => AccountUpdate.getNonceUnchecked(accountUpdate));
        accountUpdate.account.nonce.assertEquals(nonce);
        accountUpdate.body.incrementNonce = Bool(true);
        Authorization.setLazySignature(accountUpdate, { privateKey: signer });
        Mina.currentTransaction.get().accountUpdates.push(accountUpdate);
        return accountUpdate;
    }
    /**
     * Use this method to pay the account creation fee for another account.
     * Beware that you _don't_ need to pass in the new account!
     * Instead, the protocol will automatically identify accounts in your transaction that need funding.
     *
     * If you provide an optional `initialBalance`, this will be subtracted from the fee-paying account as well,
     * but you have to separately ensure that it's added to the new account's balance.
     *
     * @param feePayerKey the private key of the account that pays the fee
     * @param initialBalance the initial balance of the new account (default: 0)
     */
    static fundNewAccount(feePayerKey, { initialBalance = UInt64.zero } = {}) {
        let accountUpdate = AccountUpdate.createSigned(feePayerKey);
        let amount = initialBalance instanceof UInt64
            ? initialBalance
            : UInt64.fromString(`${initialBalance}`);
        accountUpdate.balance.subInPlace(amount.add(Mina.accountCreationFee()));
    }
    static witness(type, compute, { skipCheck = false } = {}) {
        // construct the circuit type for a accountUpdate + other result
        let accountUpdateType = circuitArray(Field, Types.AccountUpdate.sizeInFields());
        let combinedType = circuitValue({
            accountUpdate: accountUpdateType,
            result: type,
        });
        // compute the witness, with the accountUpdate represented as plain field elements
        // (in the prover, also store the actual accountUpdate)
        let proverAccountUpdate;
        let fieldsAndResult = Circuit.witness(combinedType, () => {
            let { accountUpdate, result } = compute();
            proverAccountUpdate = accountUpdate;
            let fields = Types.AccountUpdate.toFields(accountUpdate).map((x) => x.toConstant());
            return { accountUpdate: fields, result };
        });
        // get back a Types.AccountUpdate from the fields + aux (where aux is just the default in compile)
        let aux = Types.AccountUpdate.toAuxiliary(proverAccountUpdate);
        let rawAccountUpdate = Types.AccountUpdate.fromFields(fieldsAndResult.accountUpdate, aux);
        // usually when we introduce witnesses, we add checks for their type-specific properties (e.g., booleanness).
        // a accountUpdate, however, might already be forced to be valid by the on-chain transaction logic,
        // allowing us to skip expensive checks in user proofs.
        if (!skipCheck)
            Types.AccountUpdate.check(rawAccountUpdate);
        // construct the full AccountUpdate instance from the raw accountUpdate + (maybe) the prover accountUpdate
        let accountUpdate = new AccountUpdate(rawAccountUpdate.body, rawAccountUpdate.authorization);
        accountUpdate.lazyAuthorization =
            proverAccountUpdate &&
                cloneCircuitValue(proverAccountUpdate.lazyAuthorization);
        accountUpdate.children = proverAccountUpdate?.children ?? {
            accountUpdates: [],
        };
        accountUpdate.parent = proverAccountUpdate?.parent;
        return { accountUpdate, result: fieldsAndResult.result };
    }
    /**
     * Like AccountUpdate.witness, but lets you specify a layout for the accountUpdate's children,
     * which also get witnessed
     */
    static witnessTree(resultType, childLayout, compute, options) {
        // witness the root accountUpdate
        let { accountUpdate, result } = AccountUpdate.witness(resultType, compute, options);
        // stop early if children === undefined
        if (childLayout === undefined) {
            let calls = Circuit.witness(Field, () => CallForest.hashChildren(accountUpdate));
            accountUpdate.children.calls = calls;
            return { accountUpdate, result };
        }
        let childArray = typeof childLayout === 'number'
            ? Array(childLayout).fill(0)
            : childLayout;
        let n = childArray.length;
        for (let i = 0; i < n; i++) {
            accountUpdate.children.accountUpdates[i] = AccountUpdate.witnessTree(circuitValue(null), childArray[i], () => ({
                accountUpdate: accountUpdate.children.accountUpdates[i] ?? AccountUpdate.dummy(),
                result: null,
            }), options).accountUpdate;
        }
        accountUpdate.children.calls = CallForest.hashChildren(accountUpdate);
        if (n === 0) {
            accountUpdate.children.calls.assertEquals(CallForest.emptyHash());
        }
        return { accountUpdate, result };
    }
}
const CallForest = {
    // similar to Mina_base.ZkappCommand.Call_forest.to_account_updates_list
    // takes a list of accountUpdates, which each can have children, so they form a "forest" (list of trees)
    // returns a flattened list, with `accountUpdate.body.callDepth` specifying positions in the forest
    // also removes any "dummy" accountUpdates
    toFlatList(forest, depth = 0) {
        let accountUpdates = [];
        for (let accountUpdate of forest) {
            if (accountUpdate.isDummy().toBoolean())
                continue;
            accountUpdate.body.callDepth = depth;
            let children = accountUpdate.children.accountUpdates;
            accountUpdates.push(accountUpdate, ...CallForest.toFlatList(children, depth + 1));
        }
        return accountUpdates;
    },
    // Mina_base.Zkapp_command.Digest.Forest.empty
    emptyHash() {
        return Field.zero;
    },
    // similar to Mina_base.Zkapp_command.Call_forest.accumulate_hashes
    // hashes a accountUpdate's children (and their children, and ...) to compute the `calls` field of ZkappPublicInput
    hashChildren({ children }) {
        // only compute calls if it's not there yet --
        // this gives us the flexibility to witness a specific layout of accountUpdates
        if (children.calls !== undefined)
            return children.calls;
        let stackHash = CallForest.emptyHash();
        for (let accountUpdate of [...children.accountUpdates].reverse()) {
            let calls = CallForest.hashChildren(accountUpdate);
            let nodeHash = hashWithPrefix(prefixes.accountUpdateNode, [
                accountUpdate.hash(),
                calls,
            ]);
            let newHash = hashWithPrefix(prefixes.accountUpdateCons, [
                nodeHash,
                stackHash,
            ]);
            // skip accountUpdate if it's a dummy
            stackHash = Circuit.if(accountUpdate.isDummy(), stackHash, newHash);
        }
        return stackHash;
    },
    forEach(updates, callback) {
        for (let update of updates) {
            callback(update);
            CallForest.forEach(update.children.accountUpdates, callback);
        }
    },
    forEachPredecessor(updates, update, callback) {
        let isPredecessor = true;
        CallForest.forEach(updates, (otherUpdate) => {
            if (otherUpdate === update)
                isPredecessor = false;
            if (isPredecessor)
                callback(otherUpdate);
        });
    },
};
function createChildAccountUpdate(parent, childAddress, tokenId) {
    let child = AccountUpdate.defaultAccountUpdate(childAddress, tokenId);
    makeChildAccountUpdate(parent, child);
    return child;
}
function makeChildAccountUpdate(parent, child) {
    child.body.callDepth = parent.body.callDepth + 1;
    child.parent = parent;
    if (!parent.children.accountUpdates.find((accountUpdate) => accountUpdate === child)) {
        parent.children.accountUpdates.push(child);
    }
}
function zkappCommandToJson({ feePayer, accountUpdates, memo }) {
    memo = Ledger.memoToBase58(memo);
    return Types.ZkappCommand.toJSON({ feePayer, accountUpdates, memo });
}
const Authorization = {
    hasLazyProof(accountUpdate) {
        return accountUpdate.lazyAuthorization?.kind === 'lazy-proof';
    },
    hasAny(accountUpdate) {
        let { authorization: auth, lazyAuthorization: lazyAuth } = accountUpdate;
        return !!(lazyAuth || 'proof' in auth || 'signature' in auth);
    },
    setSignature(accountUpdate, signature) {
        accountUpdate.authorization = { signature };
        accountUpdate.lazyAuthorization = undefined;
    },
    setProof(accountUpdate, proof) {
        accountUpdate.authorization = { proof };
        accountUpdate.lazyAuthorization = undefined;
    },
    setLazySignature(accountUpdate, signature) {
        signature ?? (signature = {});
        accountUpdate.authorization = {};
        accountUpdate.lazyAuthorization = { ...signature, kind: 'lazy-signature' };
    },
    setLazyProof(accountUpdate, proof) {
        accountUpdate.authorization = {};
        accountUpdate.lazyAuthorization = { ...proof, kind: 'lazy-proof' };
    },
};
function addMissingSignatures(zkappCommand, additionalKeys = []) {
    let additionalPublicKeys = additionalKeys.map((sk) => sk.toPublicKey());
    let { commitment, fullCommitment } = Ledger.transactionCommitments(JSON.stringify(zkappCommandToJson(zkappCommand)));
    function addFeePayerSignature(accountUpdate) {
        let { body, authorization, lazyAuthorization } = cloneCircuitValue(accountUpdate);
        if (lazyAuthorization === undefined)
            return { body, authorization };
        let { privateKey } = lazyAuthorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
            if (i === -1) {
                let pk = PublicKey.toBase58(accountUpdate.body.publicKey);
                throw Error(`addMissingSignatures: Cannot add signature for fee payer (${pk}), private key is missing.`);
            }
            privateKey = additionalKeys[i];
        }
        let signature = Ledger.signFieldElement(fullCommitment, privateKey);
        return { body, authorization: signature };
    }
    function addSignature(accountUpdate) {
        accountUpdate = AccountUpdate.clone(accountUpdate);
        if (accountUpdate.lazyAuthorization?.kind !== 'lazy-signature') {
            return accountUpdate;
        }
        let { privateKey } = accountUpdate.lazyAuthorization;
        if (privateKey === undefined) {
            let i = additionalPublicKeys.findIndex((pk) => pk.equals(accountUpdate.body.publicKey).toBoolean());
            if (i === -1)
                throw Error(`addMissingSignatures: Cannot add signature for ${accountUpdate.publicKey.toBase58()}, private key is missing.`);
            privateKey = additionalKeys[i];
        }
        let transactionCommitment = accountUpdate.body.useFullCommitment.toBoolean()
            ? fullCommitment
            : commitment;
        let signature = Ledger.signFieldElement(transactionCommitment, privateKey);
        Authorization.setSignature(accountUpdate, signature);
        return accountUpdate;
    }
    let { feePayer, accountUpdates, memo } = zkappCommand;
    return {
        feePayer: addFeePayerSignature(feePayer),
        accountUpdates: accountUpdates.map(addSignature),
        memo,
    };
}
let ZkappPublicInput = circuitValue({ accountUpdate: Field, calls: Field }, { customObjectKeys: ['accountUpdate', 'calls'] });
function accountUpdateToPublicInput(self) {
    let accountUpdate = self.hash();
    let calls = CallForest.hashChildren(self);
    return { accountUpdate, calls };
}
async function addMissingProofs(zkappCommand) {
    async function addProof(accountUpdate) {
        accountUpdate = AccountUpdate.clone(accountUpdate);
        if (accountUpdate.lazyAuthorization?.kind !== 'lazy-proof') {
            return {
                accountUpdateProved: accountUpdate,
                proof: undefined,
            };
        }
        let { methodName, args, previousProofs, ZkappClass, memoized, blindingValue, } = accountUpdate.lazyAuthorization;
        let publicInput = accountUpdateToPublicInput(accountUpdate);
        let publicInputFields = ZkappPublicInput.toFields(publicInput);
        if (ZkappClass._provers === undefined)
            throw Error(`Cannot prove execution of ${methodName}(), no prover found. ` +
                `Try calling \`await ${ZkappClass.name}.compile()\` first, this will cache provers in the background.`);
        let provers = ZkappClass._provers;
        let methodError = `Error when computing proofs: Method ${methodName} not found. ` +
            `Make sure your environment supports decorators, and annotate with \`@method ${methodName}\`.`;
        if (ZkappClass._methods === undefined)
            throw Error(methodError);
        let i = ZkappClass._methods.findIndex((m) => m.methodName === methodName);
        if (i === -1)
            throw Error(methodError);
        let [, [, proof]] = await snarkContext.runWithAsync({
            inProver: true,
            witnesses: [accountUpdate.publicKey, accountUpdate.tokenId, ...args],
            proverData: accountUpdate,
        }, () => memoizationContext.runWithAsync({ memoized, currentIndex: 0, blindingValue }, () => provers[i](publicInputFields, previousProofs)));
        Authorization.setProof(accountUpdate, Pickles.proofToBase64Transaction(proof));
        let maxProofsVerified = ZkappClass._maxProofsVerified;
        const Proof = ZkappClass.Proof();
        return {
            accountUpdateProved: accountUpdate,
            proof: new Proof({ publicInput, proof, maxProofsVerified }),
        };
    }
    let { feePayer, accountUpdates, memo } = zkappCommand;
    // compute proofs serially. in parallel would clash with our global variable hacks
    let accountUpdatesProved = [];
    let proofs = [];
    for (let accountUpdate of accountUpdates) {
        let { accountUpdateProved, proof } = await addProof(accountUpdate);
        accountUpdatesProved.push(accountUpdateProved);
        proofs.push(proof);
    }
    return {
        zkappCommand: { feePayer, accountUpdates: accountUpdatesProved, memo },
        proofs,
    };
}
/**
 * Sign all accountUpdates of a transaction which belong to the account determined by [[ `privateKey` ]].
 * @returns the modified transaction JSON
 */
function signJsonTransaction(transactionJson, privateKey) {
    if (typeof privateKey === 'string')
        privateKey = PrivateKey.fromBase58(privateKey);
    let publicKey = privateKey.toPublicKey().toBase58();
    let zkappCommand = JSON.parse(transactionJson);
    let feePayer = zkappCommand.feePayer;
    if (feePayer.body.publicKey === publicKey) {
        zkappCommand = JSON.parse(Ledger.signFeePayer(JSON.stringify(zkappCommand), privateKey));
    }
    for (let i = 0; i < zkappCommand.accountUpdates.length; i++) {
        let accountUpdate = zkappCommand.accountUpdates[i];
        if (accountUpdate.body.publicKey === publicKey &&
            accountUpdate.authorization.proof === null) {
            zkappCommand = JSON.parse(Ledger.signAccountUpdate(JSON.stringify(zkappCommand), privateKey, i));
        }
    }
    return JSON.stringify(zkappCommand);
}
//# sourceMappingURL=account_update.js.map